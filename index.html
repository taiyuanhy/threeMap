<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title></title>
        <style>
            html,body {
                height: 100%;
                width: 100%;
                padding: 0;
                margin: 0;
                overflow: hidden;
            }

            #main {
                background-color: #ddd;
            }
        </style>
    </head>
    <body>
        <div id="main"></div>
    </body>
    <script src="lib/three.js"></script>
    <script src="lib/OrbitControls.js"></script>
    <script type="module">
        import Const from '/threeMap/src/Const.js';
        import Util from '/threeMap/src/Util.js';
        var div = document.getElementById("main");
        var width = window.innerWidth
          , height = window.innerHeight;

        div.style.width = width + "px";
        div.style.height = height + "px";

        var fov = 60;
        var ratio = width / height;
        var zoom = 18;

        var minScreenX = div.getBoundingClientRect().x;
        var minScreenY = div.getBoundingClientRect().y;
        var maxScreenX = div.getBoundingClientRect().width;
        var maxScreenY = div.getBoundingClientRect().height;

        var scene, camera, cameraControls, renderer;

        scene = new THREE.Scene();
        let tileRoot = new THREE.Group();
        scene.add(tileRoot);
        let overlayRoot = new THREE.Group();
        scene.add(overlayRoot);
        var centerLonlat = [ 116.5, 39.9];
        var worldPos = Util.LonLat2WebGL (centerLonlat[0],centerLonlat[1]);

        camera = new THREE.PerspectiveCamera(fov,ratio,1,100000000);
        camera.position.x = worldPos[0];
        camera.position.y =worldPos[1];
        camera.position.z = 500;


        Util.camera = camera;
        renderer = new THREE.WebGLRenderer({
            antialias: true//抗锯齿
        });
        renderer.setSize(width, height);
        renderer.setClearColor(0x000000);

        cameraControls = new THREE.OrbitControls(camera,renderer.domElement);
        cameraControls.enableDamping = true;
        cameraControls.target.set(worldPos[0], worldPos[1], worldPos[2]);
//        cameraControls.maxDistance = 400;
//        cameraControls.minDistance = 10;
        cameraControls.enablePan=true;
        cameraControls.ennableZoom=false;
        cameraControls.enableRotate=false;
        cameraControls.mouseButtons = { ORBIT: THREE.MOUSE.RIGHT, ZOOM: THREE.MOUSE.MIDDLE, PAN: THREE.MOUSE.LEFT };
        cameraControls.update();
        div.appendChild(renderer.domElement);
        let lastCameraPos=new THREE.Vector3();
        lastCameraPos.copy(camera.position);
        let count = 0;
        var render = function() {
            cameraControls.update();
            if(!lastCameraPos.equals(camera.position)) {
                count++;
                if (count > 60) {
                    var ev = new Event('cameraChange', {position: camera.position, oldPosition: lastCameraPos});
                    lastCameraPos.copy(camera.position);
                    div.dispatchEvent(ev);
                    count = 0;
                }
            }
            renderer.render(scene, camera);
            requestAnimationFrame(render);
        };

        render();
        initListener();

        function initListener() {
            var onmousedown = function(event) {
                if(event.button===0) {
                    div.style.cursor = "move";
                }
            };

            var onmouseup = function(event) {
                if(event.button===0){
                    div.style.cursor = "default";

                }
            };
            var redrawTile = function(event){
                worldPos = cameraControls.target;
                centerLonlat = Util.WebMercator2LonLat(worldPos.x,worldPos.y);
                zoom = Util.getZoom(minScreenX,minScreenY,maxScreenX,maxScreenY);
                for (var i =tileRoot.children.length;i>=0;i--){
                    tileRoot.remove(tileRoot.children[i]);
                };
                drawTile();
            }
            div.addEventListener("mousedown", onmousedown);
            div.addEventListener("mouseup", onmouseup);
            div.addEventListener("cameraChange",redrawTile,false);
        }
/*******************************************************************/


        //地图切片服务地址
        var serverURL = "https://mt0.google.cn/vt/lyrs=s&x={x}&y={y}&z={z}";


        /**
		 * 加载一个切图
		 * @param {Object} xno tile编号x
		 * @param {Object} yno tile编号y
		 * @param {Object} callback
		 */
        function loadImageTile(xno, yno, callback) {
            var url = serverURL.replace('{x}',xno).replace('{y}',yno).replace('{z}',zoom);
            var loader = new THREE.TextureLoader();
            //跨域加载图片
            loader.crossOrigin = true;
            loader.load(url, function(texture) {
                console.log("loaded tile");
                let resolution =Util.zoomToRes(zoom);
                let realSize = Const.tileSize*resolution;
                var geometry = new THREE.PlaneGeometry(realSize,realSize,1);
                var material = new THREE.MeshBasicMaterial({
                    map: texture,
                    transparent: true,
                    side: THREE.FrontSide
                });
                var mesh = new THREE.Mesh(geometry,material);
                callback(mesh);
            });
        }
        /**
		 * 将加载的切图放到scene
		 * @param {Object} mesh
		 * @param {Object} x坐标  WebGL坐标
		 * @param {Object} y坐标
		 */
        function addTileToScene(mesh, x, y) {
            //mesh的中心位置
            //xy是瓦片左上角的坐标,要修正
            mesh.position.x = x + mesh.geometry.parameters.width/2;
            mesh.position.y = y - mesh.geometry.parameters.height/2;
            tileRoot.add(mesh);
        }
        /**
		 * 辅助函数，用于计算tile应该放在何处
		 * @param {Object} dx  tile间相对位置，也就是编号差
		 * @param {Object} dy
		 */
        function addTileToSceneHelper(x,y,z) {
            var lonlat =Util.num2deg(x,y,z);
            var mercatorXY = Util.LonLat2WebMercator(lonlat[0],lonlat[1]);
            return function(mesh) {
                addTileToScene(mesh, mercatorXY[0], mercatorXY[1]);
            };
        }


        /**
		 * 加载地图
		 * @param {Object} centerX 地图中间的切图编号
		 * @param {Object} centerY 地图中间的切图编号
		 */
        function loadMap() {
            let topLeft = Util.screenXYToLonlat(minScreenX,minScreenY,maxScreenX,maxScreenY);
            let bottomRight = Util.screenXYToLonlat(maxScreenX,maxScreenY,maxScreenX,maxScreenY);
            let minNumXY = Util.LonLat2Num(topLeft[0], topLeft[1],zoom);
            let maxNumXY = Util.LonLat2Num(bottomRight[0], bottomRight[1],zoom);
            for (var i = minNumXY[0]; i <= maxNumXY[0]; i++) {
                for (var j = minNumXY[1]; j <= maxNumXY[1]; j++) {
                    //console.log("try to load",i,j,i-centerX,j-centerY);
                    console.log("try to load");
                    loadImageTile(i, j, addTileToSceneHelper(i, j,zoom));
                }
            }
        }
        /**
		 * 标记出当前位置
		 * @param {Object} x webGL坐标
		 * @param {Object} y
		 */
        function markCurrentPosition(x, y) {
            var geometry = new THREE.SphereGeometry(10,30,30);
            var material = new THREE.MeshBasicMaterial({
                color: 0xff0000
            });
            var mesh = new THREE.Mesh(geometry,material);
            var axes = new THREE.AxisHelper(50);
            mesh.add(axes);
            mesh.position.x = x;
            mesh.position.y = y;
            mesh.position.z = 0;
            overlayRoot.add(mesh);
        }


        function drawTile() {
            let lng = centerLonlat[0];
            let lat = centerLonlat[1];
            var tilePos = Util.LonLat2Num(lng, lat,zoom);
                //以centerLng所在点tile中心点为中心，加载tile
            loadMap(tilePos[0], tilePos[1]);
            //标记当前位置
//            var currentWebGLPos = LonLat2WebGL(lng,lat);
//            markCurrentPosition(currentWebGLPos[0],currentWebGLPos[1]);
        }
        drawTile();
    </script>
</html>
